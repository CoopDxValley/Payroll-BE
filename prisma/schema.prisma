generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Company {
  id               String        @id @default(uuid())
  status           CompanyStatus @default(pending)
  organizationName String
  phoneNumber      String
  companyCode      String
  email            String?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  notes            String?

  idFormat  IdFormat?
  accounts  Account[]
  positions Position[]
  Role      Role[]
  Grade     Grade[]

  AdditionalDeductionDefinition AdditionalDeductionDefinition[]
  additionalDeductions          AdditionalDeduction[]
  AdditionalPayDefinition       AdditionalPayDefinition[]
  additionalPays                AdditionalPay[]
  employees                     Employee[]
  departments                   Department[]
  ApprovalWorkflow              ApprovalWorkflow[]

  companyTaxRules          CompanyTaxRule[]
  DeductionDefinition      DeductionDefinition[]
  AllowanceDefinition      AllowanceDefinition[]
  allowances               Allowance[]
  deductions               Deduction[]
  CompanyPensionRule       CompanyPensionRule[]
  CompanyProvidentFundRule CompanyProvidentFundRule[]

  workingCalendar     WorkingCalendar[]
  shift               Shift[]
  OvertimeGracePeriod OvertimeGracePeriod[]
  payrollDefinitions  PayrollDefinition[]

  //shiftSchedules  ShiftSchedule[]
  rotatingShiftTypes     RotatingShiftType[]

  
  shiftSchedules ShiftSchedule[]
}

enum Separator {
  SLASH // "/"
  DASH // "-"
}

model IdFormat {
  id          String    @id @default(uuid())
  companyCode Boolean?
  year        Boolean?
  department  Boolean?
  separator   Separator @default(SLASH)
  isActive    Boolean   @default(true)
  digitLength Int       @default(5)
  order       String

  companyId String  @unique
  company   Company @relation(fields: [companyId], references: [id])

  @@map("IdFormat")
}

model Account {
  id            String   @id @default(uuid())
  companyId     String
  accountNumber String
  isMaster      Boolean  @default(false)
  isVerified    Boolean  @default(false)
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  company       Company  @relation(fields: [companyId], references: [id])
}

//model Department {
// id                      String     @id @default(uuid())
// deptName                String
// location                String?
// shorthandRepresentation String?
// companyId               String
// isActive                Boolean    @default(true)
// createdAt               DateTime   @default(now())
// updatedAt               DateTime   @updatedAt
// company                 Company    @relation(fields: [companyId], references: [id])
//departmentEmployees     Employee[]

// approvalWorkflow        ApprovalWorkflow[]
//}

model Position {
  id           String   @id @default(uuid())
  positionName String
  description  String?
  companyId    String
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  company     Company                   @relation(fields: [companyId], references: [id])
  assignments EmployeePositionHistory[]
  //employeePositions Employee[]
}

model EmployeePositionHistory {
  id         String    @id @default(uuid())
  employeeId String
  positionId String
  fromDate   DateTime
  toDate     DateTime?

  employee Employee @relation(fields: [employeeId], references: [id])
  position Position @relation(fields: [positionId], references: [id])

  @@unique([employeeId, positionId])
}

model Role {
  id        String  @id @default(uuid())
  name      String  @unique
  companyId String
  isActive  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  company Company @relation(fields: [companyId], references: [id])

  permissions RolePermission[]
  //employeeRoles EmployeeRole[]
  assignments EmployeeRoleHistory[]
}

model Permission {
  id             String           @id @default(uuid())
  action         String
  subject        String
  action_subject String           @unique
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  roles          RolePermission[]
}

model RolePermission {
  id           String     @id @default(uuid())
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  roleId       String
  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id])
  role         Role       @relation(fields: [roleId], references: [id])

  @@unique([roleId, permissionId])
}

model Token {
  id          String    @id @default(uuid())
  token       String
  type        TokenType
  expires     DateTime
  blacklisted Boolean
  createdAt   DateTime  @default(now())

  employeeId String
  employee   Employee @relation(fields: [employeeId], references: [id])
}

//model Shift {
// id          String   @id @default(uuid())
// name        String
//  startTime   DateTime
// endTime     DateTime
// breakTime   Int // Break duration in minutes
// gracePeriod Int // Grace period in minutes
// companyId   String
// isActive    Boolean  @default(true)
// createdAt   DateTime @default(now())
// updatedAt   DateTime @updatedAt
// company     Company  @relation(fields: [companyId], references: [id])

//@@index([companyId])
//}

model Grade {
  id        String   @id @default(uuid())
  name      String
  minSalary Float
  maxSalary Float
  companyId String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  company     Company                @relation(fields: [companyId], references: [id])
  assignments EmployeeGradeHistory[]
  allowances  Allowance[]
  deductions  Deduction[]

  @@index([companyId])
}

enum TokenType {
  ACCESS
  REFRESH
  RESET_PASSWORD
  VERIFY_EMAIL
}

enum CompanyStatus {
  pending
  active
  reject
  denied
}

enum GENDER {
  MALE
  FEMALE
}

enum PaymentMethod {
  PHONENUMBER
  ACCOUNTNUMBER
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REJECTED
}

///////////////

model LeaveType {
  id            String   @id @default(uuid())
  name          String
  description   String?
  maxDaysYearly Int
  isPaid        Boolean  @default(true)
  carryForward  Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  isActive      Boolean  @default(true)

  // Relations (if any - for example, with LeaveRequest model)
  //leaveRequests  LeaveRequest[]
}

model AdditionalDeductionDefinition {
  id        String        @id @default(uuid())
  name      String
  type      DeductionType
  companyId String
  isActive  Boolean       @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  company              Company               @relation(fields: [companyId], references: [id])
  additionalDeductions AdditionalDeduction[]
}

model DeductionDefinition {
  id        String  @id @default(uuid())
  name      String
  companyId String
  isActive  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  company    Company     @relation(fields: [companyId], references: [id])
  deductions Deduction[]
}

model AllowanceDefinition {
  id             String   @id @default(uuid())
  name           String
  isTaxable      Boolean  @default(false)
  isExempted     Boolean  @default(false)
  exemptedAmount Decimal  @db.Decimal(10, 2)
  startingAmount Decimal? @db.Decimal(10, 2)
  companyId      String
  isActive       Boolean  @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  company    Company     @relation(fields: [companyId], references: [id])
  allowances Allowance[]
}

model Allowance {
  id                    String @id @default(uuid())
  amount                Float
  allowanceDefinitionId String
  gradeId               String
  companyId             String

  allowanceDefinition AllowanceDefinition @relation(fields: [allowanceDefinitionId], references: [id])
  grade               Grade               @relation(fields: [gradeId], references: [id])
  company             Company             @relation(fields: [companyId], references: [id])
}

model Deduction {
  id                    String @id @default(uuid())
  amount                Float
  deductionDefinitionId String
  gradeId               String
  companyId             String

  deductionDefinition DeductionDefinition @relation(fields: [deductionDefinitionId], references: [id])
  grade               Grade               @relation(fields: [gradeId], references: [id])
  company             Company             @relation(fields: [companyId], references: [id])
}

model AdditionalPayDefinition {
  id        String      @id @default(uuid())
  name      String
  type      PAYMENTTYPE
  companyId String
  isActive  Boolean     @default(true)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  additionalPays AdditionalPay[]
  company        Company         @relation(fields: [companyId], references: [id])

  @@unique([name, companyId, isActive])
}

enum PAYMENTTYPE {
  AMOUNT
  PERCENT
}

enum DeductionType {
  AMOUNT
  PERCENT
}

//////

enum PayrollCalculationType {
  FIXED_SALARY // Fixed monthly/weekly salary regardless of attendance
  HOURLY_ATTENDANCE // Hourly rate based on attendance hours
  MIXED // Base salary + attendance bonuses/deductions
  COMMISSION_BASED // Commission/piece-rate, attendance optional
  CONTRACT // Contract-based, attendance may not matter
}

enum AttendanceRequirement {
  REQUIRED // Must track attendance for payroll
  OPTIONAL // Attendance tracked but doesn't affect pay
  NOT_REQUIRED // No attendance tracking needed
}

model Employee {
  id               String  @id @default(uuid())
  name             String
  username         String  @unique
  phoneNumber      String
  password         String
  employeeIdNumber String?  @unique // Device user ID from attendance device
  deviceUserId     String?  @unique
  salaryPerHour    Decimal? @db.Decimal(10, 2)

  attendanceRequirement AttendanceRequirement @default(REQUIRED)

  isSuperAdmin        Boolean          @default(false)
  email               String?          @unique
  optionalPhoneNumber String?
  gender              Gender
  country             String?          @default("Ethiopia")
  zone                String?
  woreda              String?
  kebele              String?
  region              String?
  houseNo             String?
  dateOfBirth         DateTime?
  nationality         String?          @default("Ethiopia")
  title               String?
  imageUrl            String?
  status              EmploymentStatus @default(ACTIVE)
  idNumber            String?
  idImageUrl          String?
  idType              IdType           @default(KEBELE)
  maritalStatus       MaritalStatus    @default(SINGLE)
  companyId           String
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt
  isFirstTimeLoggedIn Boolean          @default(true)
  Token               Token[]
  company             Company          @relation(fields: [companyId], references: [id])

  gradeHistory      EmployeeGradeHistory[]
  payrollInfo       PayrollInfo?
  terminations      TerminationRecord[]
  departmentHistory EmployeeDepartmentHistory[]
  roleHistory       EmployeeRoleHistory[]
  positionHistory   EmployeePositionHistory[]
  emergencyContacts EmergencyContact[]
  overtimes         Overtime[] // From second model
//  OvertimeTable    OvertimeTable[]
  stageEmployees StageEmployee[]
  requests       Request[]
  stageStatuses  StageStatus[]

  delegatedFrom Delegation[] @relation("FromEmployee")
  delegatedTo   Delegation[] @relation("ToEmployee")

  delegatedRuleFrom    DelegationRule[]       @relation("FromEmployeeDelegationRule")
  delegatedRuleTo      DelegationRule[]       @relation("ToEmployeeDelegationRule")
  ApprovalComment      ApprovalComment[]
  ApprovalNotification ApprovalNotification[]
  ApprovalAuditLog     ApprovalAuditLog[]

  additionalDeductions AdditionalDeduction[]
  additionalPays       AdditionalPay[]

  // Shift coverage relations from second model
  employeeShifts         EmployeeShift[]
  originalShiftCoverages ShiftCoverage[] @relation("OriginalShiftEmployee")
  coveringShiftCoverages ShiftCoverage[] @relation("CoveringShiftEmployee")
  requestedCoverages     ShiftCoverage[] @relation("ShiftCoverageRequester")
  approvedCoverages      ShiftCoverage[] @relation("ShiftCoverageApprover")

  shiftAssignments EmployeeShiftAssignment[]
  Payroll          Payroll?

  //workSessions  WorkSession[] 

  @@index([name])
  @@index([phoneNumber])
}

enum MaritalStatus {
  SINGLE
  MARRIED
  DIVORCED
  WIDOWED
}

model AdditionalDeduction {
  id                              String  @id @default(uuid())
  amount                          Decimal @db.Decimal(10, 2)
  employeeId                      String
  additionalDeductionDefinitionId String
  companyId                       String

  employee                      Employee                      @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  additionalDeductionDefinition AdditionalDeductionDefinition @relation(fields: [additionalDeductionDefinitionId], references: [id], onDelete: Cascade)
  company                       Company                       @relation(fields: [companyId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([employeeId])
  @@index([additionalDeductionDefinitionId])
  @@index([companyId])
}

model AdditionalPay {
  id     String  @id @default(uuid())
  amount Decimal @db.Decimal(10, 2)

  additionalPayDefinitionId String
  employeeId                String
  companyId                 String

  additionalPayDefinition AdditionalPayDefinition @relation(fields: [additionalPayDefinitionId], references: [id], onDelete: Cascade)
  employee                Employee                @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  company                 Company                 @relation(fields: [companyId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([additionalPayDefinitionId])
  @@index([employeeId])
  @@index([companyId])
}

model TaxSlab {
  id          String  @id @default(uuid())
  name        String?
  description String?
  type        TaxType @default(INCOME_TAX)
  rate        Float?
  deductible  Float?  @default(0)
  incomeTaxPayable  Float? @default(0)  
  minIncome   Float
  maxIncome   Float
  isDefault   Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  companyTaxRules CompanyTaxRule[]
}

model ProvidentFund {
  id                   String  @id @default(uuid())
  employerContribution Float
  employeeContribution Float
  isDefault            Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  companyProvidentFundRule CompanyProvidentFundRule[]
}

model Pension {
  id                   String  @id @default(uuid())
  employerContribution Float
  employeeContribution Float
  isDefault            Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  companyPensionRule CompanyPensionRule[]
}

model CompanyTaxRule {
  id        String  @id @default(uuid())
  companyId String
  taxSlabId String
  isActive  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  taxSlab TaxSlab @relation(fields: [taxSlabId], references: [id], onDelete: Cascade)

  @@unique([companyId, taxSlabId])
  @@index([companyId])
  @@index([taxSlabId])
}

model CompanyPensionRule {
  id        String  @id @default(uuid())
  companyId String
  pensionId String
  isActive  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  pension Pension @relation(fields: [pensionId], references: [id], onDelete: Cascade)

  @@unique([companyId, pensionId])
  @@index([companyId])
  @@index([pensionId])
}

model CompanyProvidentFundRule {
  id              String  @id @default(uuid())
  companyId       String
  providentFundId String
  isActive        Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  company       Company       @relation(fields: [companyId], references: [id], onDelete: Cascade)
  providentFund ProvidentFund @relation(fields: [providentFundId], references: [id], onDelete: Cascade)

  @@unique([companyId, providentFundId])
  @@index([companyId])
  @@index([providentFundId])
}

enum TaxType {
  INCOME_TAX
  EXEMPTION
}

enum ProvidentFundType {
  EMPLOYEE
  EMPLOYER
}

model Department {
  id                      String   @id @default(uuid())
  deptName                String
  parentId                String? // optional for tree structure
  location                String?
  shorthandRepresentation String
  companyId               String
  //departmentEmployees     Employee[]
  isActive                Boolean  @default(true)
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  parent           Department?                 @relation("DepartmentHierarchy", fields: [parentId], references: [id])
  children         Department[]                @relation("DepartmentHierarchy")
  assignments      EmployeeDepartmentHistory[]
  company          Company                     @relation(fields: [companyId], references: [id])
  approvalWorkflow ApprovalWorkflow[]
}

model EmployeeDepartmentHistory {
  id           String    @id @default(uuid())
  employeeId   String
  departmentId String
  fromDate     DateTime
  toDate       DateTime?

  employee   Employee   @relation(fields: [employeeId], references: [id])
  department Department @relation(fields: [departmentId], references: [id])

  @@unique([employeeId, departmentId])
}

model EmployeeGradeHistory {
  employeeId String
  gradeId    String
  fromDate   DateTime
  toDate     DateTime?

  employee Employee @relation(fields: [employeeId], references: [id])
  grade    Grade    @relation(fields: [gradeId], references: [id])

  @@unique([employeeId, gradeId])
}

enum Gender {
  MALE
  FEMALE
}

enum EmploymentStatus {
  ACTIVE
  INACTIVE
  TERMINATED
  ON_LEAVE
  RETIRED
}

enum IdType {
  KEBELE
  PASSPORT
  LICENSE
  NATIONALID
}

model PayrollInfo {
  id             String         @id @default(uuid())
  employeeId     String         @unique
  tinNumber      String         @unique
  hireDate       DateTime
  basicSalary    Float
  currency       String         @default("ETB")
  employmentType EmploymentType
  payFrequency   PayFrequency   @default(MONTHLY)
  accountNumber  String         @unique

  employee Employee @relation(fields: [employeeId], references: [id])
}

enum EmploymentType {
  PERMANENT
  CONTRACT
  HOURLY
}

enum PayFrequency {
  MONTHLY
  BIWEEKLY
  WEEKLY
  DAILY
}

model TerminationRecord {
  id              String          @id @default(uuid())
  employeeId      String
  reason          String
  terminationType TerminationType
  noticeDate      DateTime
  terminationDate DateTime
  remarks         String?

  employee Employee @relation(fields: [employeeId], references: [id])
}

enum TerminationType {
  RESIGNATION
  DISMISSAL
  RETIREMENT
  DECEASED
}

model Attendance {
  id           String    @id @default(uuid())
  deviceUserId String // ✅ now the only identifier
  date         DateTime  @db.Date
  checkTime    DateTime
  checkType    CheckType // ✅ enum for punch type
  verifyMode   Int?
  workCode     Int?
  sensorId     String?
  deviceIp     String?
  isAbsent     Boolean   @default(false)
  createdAt    DateTime  @default(now())

  @@index([deviceUserId, date])
}

enum CheckType {
  PUNCHIN
  PUNCHOUT
}

model EmployeeRoleHistory {
  employeeId String
  roleId     String
  fromDate   DateTime
  toDate     DateTime?

  role     Role     @relation(fields: [roleId], references: [id])
  employee Employee @relation(fields: [employeeId], references: [id])

  @@id([employeeId, roleId])
}

model EmergencyContact {
  id           String  @id @default(uuid())
  employeeId   String
  fullName     String
  relationship String
  phone        String
  email        String?
  address      String?

  employee  Employee @relation(fields: [employeeId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

//////

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum ApprovalStageStatus {
  PENDING
  APPROVED
  REJECTED
  DELEGATED
}

enum RequestType {
  ATTENDANCE
  PAYROLL
  EXPENSE
  PROGRAM
}

model ApprovalWorkflow {
  id              String      @id @default(uuid())
  name            String
  companyId       String
  departmentId    String?
  requestType     RequestType
  isFullyParallel Boolean
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  company    Company            @relation(fields: [companyId], references: [id])
  department Department?        @relation(fields: [departmentId], references: [id])
  stages     ApprovalStage[]
  instances  ApprovalInstance[]

  @@unique([requestType, companyId, departmentId])
}

model ApprovalStage {
  id            String   @id @default(uuid())
  workflowId    String
  isParallel    Boolean
  approvalRules Json
  order         Int
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  workflow       ApprovalWorkflow   @relation(fields: [workflowId], references: [id])
  stageEmployees StageEmployee[]
  stageStatuses  StageStatus[]
  instances      ApprovalInstance[] @relation("ActiveStages")
}

model StageEmployee {
  id         String   @id @default(uuid())
  stageId    String
  employeeId String
  weight     Int?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  stage    ApprovalStage @relation(fields: [stageId], references: [id])
  employee Employee      @relation(fields: [employeeId], references: [id])

  @@unique([stageId, employeeId])
}

model Request {
  id          String      @id @default(uuid())
  type        RequestType
  requestedBy String
  moduleId    String
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  requestor Employee           @relation(fields: [requestedBy], references: [id])
  instance  ApprovalInstance[]
}

model ApprovalInstance {
  id                 String         @id @default(uuid())
  requestId          String
  workflowId         String
  activeStageIds     String[]
  status             ApprovalStatus @default(PENDING)
  version            Int            @default(1)
  parentInstanceId   String?
  resubmissionReason String?
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt

  request              Request                @relation(fields: [requestId], references: [id])
  workflow             ApprovalWorkflow       @relation(fields: [workflowId], references: [id])
  parentInstance       ApprovalInstance?      @relation("Resubmissions", fields: [parentInstanceId], references: [id])
  resubmissions        ApprovalInstance[]     @relation("Resubmissions")
  activeStages         ApprovalStage[]        @relation("ActiveStages")
  stageStatuses        StageStatus[]
  ApprovalComment      ApprovalComment[]
  ApprovalNotification ApprovalNotification[]
  ApprovalAuditLog     ApprovalAuditLog[]
}

model StageStatus {
  id         String              @id @default(uuid())
  instanceId String
  stageId    String
  approvedBy String?
  status     ApprovalStageStatus
  comments   String?
  approvedAt DateTime?
  createdAt  DateTime            @default(now())
  updatedAt  DateTime            @updatedAt

  instance   ApprovalInstance @relation(fields: [instanceId], references: [id])
  stage      ApprovalStage    @relation(fields: [stageId], references: [id])
  approver   Employee?        @relation(fields: [approvedBy], references: [id])
  Delegation Delegation[]

  @@unique([instanceId, stageId, approvedBy])
}

model ApprovalComment {
  id         String           @id @default(uuid())
  instanceId String
  authorId   String
  comment    String
  createdAt  DateTime         @default(now())
  instance   ApprovalInstance @relation(fields: [instanceId], references: [id])
  author     Employee         @relation(fields: [authorId], references: [id])
}

model ApprovalNotification {
  id          String           @id @default(uuid())
  instanceId  String
  recipientId String
  message     String
  read        Boolean          @default(false)
  createdAt   DateTime         @default(now())
  instance    ApprovalInstance @relation(fields: [instanceId], references: [id])
  recipient   Employee         @relation(fields: [recipientId], references: [id])
}

model ApprovalAuditLog {
  id          String           @id @default(uuid())
  instanceId  String
  action      String
  performedBy String
  details     String?
  createdAt   DateTime         @default(now())
  instance    ApprovalInstance @relation(fields: [instanceId], references: [id])
  performer   Employee         @relation(fields: [performedBy], references: [id])
}

model Delegation {
  id             String      @id @default(uuid())
  stageStatusId  String
  fromEmployeeId String
  toEmployeeId   String
  reason         String?
  createdAt      DateTime    @default(now())
  stageStatus    StageStatus @relation(fields: [stageStatusId], references: [id])
  fromEmployee   Employee    @relation("FromEmployee", fields: [fromEmployeeId], references: [id])
  toEmployee     Employee    @relation("ToEmployee", fields: [toEmployeeId], references: [id])
}

model DelegationRule {
  id             String      @id @default(uuid())
  requestType    RequestType
  fromEmployeeId String // The employee that would normally approve
  toEmployeeId   String // The employee to whom it should be delegated
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  fromEmployee Employee @relation("FromEmployeeDelegationRule", fields: [fromEmployeeId], references: [id])
  toEmployee   Employee @relation("ToEmployeeDelegationRule", fields: [toEmployeeId], references: [id])
}

model WorkingCalendar {
  id          String          @id @default(uuid())
  companyId   String
  year        Int
  date        DateTime        @db.Date
  dayType     CalendarDayType @default(WORKING_DAY)
  description String? // e.g., "Christmas Day", "Company Anniversary"
  isActive    Boolean         @default(true)
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  company Company @relation(fields: [companyId], references: [id])

  @@unique([companyId, date])
  @@index([companyId, year])
}

enum CalendarDayType {
  WORKING_DAY // Override - force this day to be working even if pattern says off
  HOLIDAY // Override - force this day to be off even if pattern says work
}

///////////SHIFT MANAGEMENT  /////////////////////////////////////

model Shift {
  id             String          @id @default(uuid())
  name           String // "Regular"
  companyId      String
  isActive       Boolean         @default(true)
  // cycleDays    Int      // Replaces the need for ShiftPattern
  patternDays    ShiftDay[] // Formerly ShiftPatternDay
  employeeShifts EmployeeShift[]
  company        Company         @relation(fields: [companyId], references: [id])
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  shiftType      ShiftType
  // New relation for calendar-based assignments
  shiftSchedules ShiftSchedule[] @relation("ShiftSchedulesForShift")

 shiftCoverages ShiftCoverage[]  // ← SHIFT COVERAGE
workSessions  WorkSession[] 
}

enum ShiftType {
  FIXED_WEEKLY // Always 7 days (Monday-Sunday)
  ROTATING // Variable pattern with DAY/NIGHT/OFF
}

model ShiftDay {
  id          String       @id @default(uuid())
  shiftId     String
  dayNumber   Int // 1–cycleDays
  dayType     ShiftDayType
  startTime   DateTime
  endTime     DateTime
  breakTime   Int
  gracePeriod Int
  shift       Shift        @relation(fields: [shiftId], references: [id])

  @@unique([shiftId, dayNumber]) // Prevent duplicate day numbers
  @@index([shiftId])
}

model EmployeeShift {
  id         String    @id @default(uuid())
  employeeId String
  shiftId    String
  startDate  DateTime
  endDate    DateTime?
  isActive   Boolean   @default(true)

  employee Employee @relation(fields: [employeeId], references: [id])
  shift    Shift    @relation(fields: [shiftId], references: [id])

  @@index([employeeId])
  @@index([shiftId])
}

model ShiftCoverage {
  id                 String         @id @default(uuid())
  originalEmployeeId String // Who was supposed to work
  coveringEmployeeId String // Who is covering
  shiftId            String
  coverageDate       DateTime       @db.Date
  startTime          DateTime
  endTime            DateTime
  reason             CoverageType   @default(EMERGENCY) // "sick leave", "vacation", etc.
  status             CoverageStatus @default(PENDING)
  requestedBy        String // Employee who requested coverage
  approvedBy         String? // Manager who approved
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt

  originalEmployee Employee  @relation("OriginalShiftEmployee", fields: [originalEmployeeId], references: [id])
  coveringEmployee Employee  @relation("CoveringShiftEmployee", fields: [coveringEmployeeId], references: [id])
  shift            Shift     @relation(fields: [shiftId], references: [id])
  requester        Employee  @relation("ShiftCoverageRequester", fields: [requestedBy], references: [id])
  approver         Employee? @relation("ShiftCoverageApprover", fields: [approvedBy], references: [id])

  @@unique([originalEmployeeId, shiftId, coverageDate])
  @@index([coverageDate])
}

enum CoverageStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
}

enum CoverageType {
  SICK_LEAVE // Employee is sick, needs coverage
  VACATION // Planned absence
  EMERGENCY // Emergency coverage needed
  SHIFT_SWAP // Two employees swapping shifts
  OVERTIME // Extra coverage needed
}

enum ShiftDayType {
  FULL_DAY
  HALF_DAY
  REST_DAY
  // NIGHT
}

////=======OVERTIME MANAGEMENT=============

model Overtime {
  id         String         @id @default(uuid())
  employeeId String
  date       DateTime       @db.Date
  startTime  DateTime
  endTime    DateTime
  duration   Int // Duration in minutes
  status     OvertimeStatus @default(PENDING)
  reason     OvertimeReason
  //approvedBy     String?
  approvedAt DateTime?
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  employee Employee @relation(fields: [employeeId], references: [id])
  //approver       Employee? @relation("OvertimeApprover", fields: [approvedBy], references: [id])

  @@index([employeeId, date])
  @@index([status])
}

enum OvertimeStatus {
  PENDING
  APPROVED
  REJECTED
  PAID
}

enum OvertimeReason {
  UNSCHEDULED_WORK // Work outside of scheduled shift
  EXTENDED_SHIFT // Staying beyond scheduled end time
  EMERGENCY // Emergency work requirement
  SPECIAL_PROJECT // Special project requiring extra hours
  COVERAGE // Covering for another employee
}

model OvertimeGracePeriod {
  id                 String   @id @default(uuid())
  companyId          String
  gracePeriodMinutes Int      @default(10)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  company  Company @relation(fields: [companyId], references: [id])
  isActive Boolean @default(true)

  @@index([companyId])
}

enum PayrollDefinitionStatus {
  created
  ordered
  pending
  approved
  active
  paid
  rejected
}

model PayrollDefinition {
  id          String                  @id @default(uuid())
  payrollName String
  startDate   DateTime
  endDate     DateTime
  payDate     DateTime
  payPeriod   String
  status      PayrollDefinitionStatus @default(created)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  companyId   String
  company     Company @relation(fields: [companyId], references: [id])

  Payroll     Payroll[]
}

model Payroll {
  id                  String @id @default(uuid())
  employeeId          String @unique
  payrollDefinitionId String

  grossSalary    Decimal @default(0.00) @db.Decimal(10, 2)
  basicSalary    Decimal @default(0.00) @db.Decimal(10, 2)
  taxableIncome  Decimal @default(0.00) @db.Decimal(10, 2)
  incomeTax      Decimal @default(0.00) @db.Decimal(10, 2)
  totalDeduction Decimal @default(0.00) @db.Decimal(10, 2)
  totalAllowance Decimal @default(0.00) @db.Decimal(10, 2)
  netSalary      Decimal @default(0.00) @db.Decimal(10, 2)

  employeePensionAmount Decimal @default(0.00) @db.Decimal(10, 2)
  employerPensionAmount Decimal @default(0.00) @db.Decimal(10, 2)

  status PayrollStatus @default(CREATED)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // relations
  employee          Employee          @relation(fields: [employeeId], references: [id])
  payrollDefinition PayrollDefinition @relation(fields: [payrollDefinitionId], references: [id])
}

enum PayrollStatus {
  CREATED
  PENDING
  APPROVED
  FAILED
  PAID
}

////////////// ROTATING SHIFT ASSIGNMENTS AND SCHEDULES //////////////////

// New model to group shifts over a date range (week, month, etc.)
model ShiftSchedule {
  id         String   @id @default(uuid())
  companyId  String
  shiftId    String? // optional link to a Shift if needed
  name       String // e.g. "Security August 2025 Week 1"
  startDate  DateTime @db.Date
  endDate    DateTime @db.Date
  isActive   Boolean  @default(true)
  isApproved Boolean  @default(false) // lock schedule once approved
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  company     Company                   @relation(fields: [companyId], references: [id])
  shift       Shift?                    @relation("ShiftSchedulesForShift", fields: [shiftId], references: [id])
  assignments EmployeeShiftAssignment[]

  @@index([companyId])
  @@index([startDate, endDate])
}

// Assign explicit shift type per employee per calendar date
model EmployeeShiftAssignment {
  id          String          @id @default(uuid())
  employeeId  String
  scheduleId  String?         // Link to ShiftSchedule for grouping
  date        DateTime        @db.Date
// RotatingShiftType   RotatingShiftType 
  hours       Int             // 12 for DAY/NIGHT, 0 for OFF
  isApproved  Boolean         @default(false)  // Once approved, immutable
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  employee Employee       @relation(fields: [employeeId], references: [id])
  schedule ShiftSchedule? @relation(fields: [scheduleId], references: [id])

  @@unique([employeeId, date]) // one assignment per employee per day
  @@index([employeeId])
  @@index([date])
    // NEW: Can be null for OFF days
  shiftTypeId String?         // null = OFF day, uuid = actual shift
  RotatingShiftType   RotatingShiftType? @relation(fields: [shiftTypeId], references: [id])
}

//enum RotatingShiftType  {
//DAY // 06:00 -06:00
//  NIGHT //06:60 -06:00
//  OFF
//}


model RotatingShiftType {
  id          String          @id @default(uuid())
  companyId   String
  name        String          // "DAY", "NIGHT", "MORNING", "EVENING"
  startTime   String          // "06:00", "18:00", etc.
  endTime     String          // "18:00", "06:00", etc.
  duration    Int             // hours
  isActive    Boolean         @default(true)
    // <-- Add this back-relation
  employeeShiftAssignments EmployeeShiftAssignment[]


  
   company     Company         @relation(fields: [companyId], references: [id])
   @@index([companyId])
}



/////UPDATED  ATTENDANCE HANDLING

model WorkSession {
  id            String      @id @default(uuid())
  deviceUserId    String
  date          DateTime      @db.Date
  punchIn       DateTime?
  punchOut      DateTime?
  duration      Int?          // in minutes
  shiftId       String?
  //dayType       CalendarDayType
  //status        SessionStatus
  earlyMinutes  Int?          @default(0)
  lateMinutes   Int?          @default(0)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  dedutedMinutes Int?          @default(0)
//  employee      Employee      @relation(fields: [employeeId], references: [id])
  shift         Shift?        @relation(fields: [shiftId], references: [id])
  OvertimeTable      OvertimeTable[]

  punchInSource   String        @default("manual")  // Default: manual
  punchOutSource  String        @default("manual")  // Default: manual
}


model OvertimeTable {
  id            String         @id @default(uuid())
  workSessionId String?
  deviceUserId    String
  date          DateTime      @db.Date  // Date when overtime occurred
  punchIn     DateTime      // Actual overtime start time
  punchOut      DateTime?     // Actual overtime end time
  duration      Int  ?        // in minutes
  type          OvertimeType
  status        OvertimeStatus @default(PENDING)
//payMultiplier Float        @default(1.5)
  //isCrossDay    Boolean      @default(false)
  notes         String?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  // Relations
  workSession   WorkSession?  @relation(fields: [workSessionId], references: [id])
  //employee      Employee     @relation(fields: [employeeId], references: [id])

  @@index([workSessionId])
//  @@index([employeeId, date])
  @@index([status])

  punchInSource   String        @default("manual")  // Default: manual
  punchOutSource  String        @default("manual")  // Default: manual
}

enum OvertimeType {
  EARLY_ARRIVAL    // Before shift start
  LATE_DEPARTURE   // After shift end
  HOLIDAY_WORK     // Worked on holiday
  REST_DAY_WORK    // Worked on rest day
  EXTENDED_SHIFT   // Beyond max shift hours
  UNSCHEDULED      // No shift scheduled
}

